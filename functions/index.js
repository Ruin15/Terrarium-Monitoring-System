// Firebase Cloud Functions
// File: functions/index.js

const { onValueUpdated } = require("firebase-functions/v2/database");
const { onSchedule } = require("firebase-functions/v2/scheduler");
const { defineString } = require("firebase-functions/params");
const admin = require("firebase-admin");
const nodemailer = require("nodemailer");

// Initialize Firebase Admin
admin.initializeApp();
const db = admin.firestore();


// Define configuration parameters for Brevo email service
// These will be prompted during deployment or can be set via .env files
const brevoSmtpServer = defineString("BREVO_SMTP_SERVER", {
  description: "Brevo SMTP server hostname",
  default: "smtp-relay.brevo.com",
});

const brevoSmtpPort = defineString("BREVO_SMTP_PORT", {
  description: "Brevo SMTP port number",
  default: "587",
});

const brevoSmtpLogin = defineString("BREVO_SMTP_LOGIN", {
  description: "Brevo SMTP login username",
  default: "a0ee7d001@smtp-brevo.com",
});

const brevoSmtpKey = defineString("BREVO_SMTP_KEY", {
  description: "Brevo SMTP API key",
});

const brevoSenderEmail = defineString("BREVO_SENDER_EMAIL", {
  description: "Email address to send notifications from",
  default: "repsajodimus5@gmail.com",
});

const brevoSenderName = defineString("BREVO_SENDER_NAME", {
  description: "Name to display as email sender",
  default: "Terrarium Monitor",
});


/**
 * Sends an email notification for a sensor alert
 * @param {string} userEmail - The recipient's email address
 * @param {Object} alert - The alert object
 * @param {string} ecosystem - The ecosystem type (tropical, desert, etc.)
 * @return {Promise} Promise with email info
 */
async function sendAlertEmail(userEmail, alert, ecosystem) {
  try {
    // Create the transporter with current param values
    // We do this inside the function to ensure params are properly initialized
    const transporter = nodemailer.createTransport({
      host: brevoSmtpServer.value(),
      port: parseInt(brevoSmtpPort.value()),
      secure: false, // Use TLS (STARTTLS), not SSL
      auth: {
        user: brevoSmtpLogin.value(),
        pass: brevoSmtpKey.value(),
      },
    });

    // Build a user-friendly subject line based on severity
    const subject = alert.severity === "critical" ?
      `üö® CRITICAL ALERT: ${alert.type} issue in ${ecosystem} terrarium` :
      `‚ö†Ô∏è Warning: ${alert.type} issue in your ${ecosystem} terrarium`;

    // Create the email body with helpful information
    const htmlBody = `
      <div style="font-family: Arial, sans-serif;
        max-width: 600px; margin: 0 auto;">
        <h2 style="color: ${alert.severity === "critical" ?
    "#dc2626" : "#f59e0b"};">
          ${alert.severity === "critical" ?
    "üö® Critical Alert" : "‚ö†Ô∏è Warning"}
        </h2>
        <p><strong>Alert Type:</strong>
          ${alert.type.charAt(0).toUpperCase() + alert.type.slice(1)}</p>
        <p><strong>Current Value:</strong>
          ${alert.value}${alert.type === "temperature" ? "¬∞C" :
    alert.type === "lux" ? " lux" : "%"}</p>
        <p><strong>Threshold:</strong>
          ${alert.threshold}${alert.type === "temperature" ? "¬∞C" :
    alert.type === "lux" ? " lux" : "%"}</p>
        <p><strong>Message:</strong> ${alert.message}</p>
        <p><strong>Ecosystem:</strong>
          ${ecosystem.charAt(0).toUpperCase() + ecosystem.slice(1)}</p>
        <p><strong>Date:</strong> ${alert.date}</p>
        <hr style="margin: 20px 0;">
        <p style="color: #666; font-size: 14px;">
          This alert was generated by your Terrarium Monitoring System. 
          Please check your terrarium conditions and take action.
        </p>
      </div>
    `;

    // Configure the email message
    const mailOptions = {
      from: `"${brevoSenderName.value()}" <${brevoSenderEmail.value()}>`,
      to: userEmail,
      subject: subject,
      html: htmlBody,
    };

    // Send the email
    const info = await transporter.sendMail(mailOptions);
    console.log(`‚úâÔ∏è Email sent successfully to ${userEmail}:`,
        info.messageId);
    return info;
  } catch (error) {
    console.error(`‚ùå Error sending email to ${userEmail}:`, error);
    throw error;
  }
}


/**
 * Cloud Function: Cleanup old alerts
 * Runs daily to delete alert data older than 7 days
 * Helps maintain database performance and manage storage costs
 */
exports.cleanupOldAlerts = onSchedule(
    {
      schedule: "every 24 hours",
      region: "asia-southeast1",
    },
    async (event) => {
      try {
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const cutoffDate = sevenDaysAgo.toISOString().split("T")[0];
        const cutoffTimestamp = sevenDaysAgo.getTime();

        console.log(`üóëÔ∏è Starting alert cleanup for alerts older than ${cutoffDate}`);

        // Query alerts older than 7 days using the date field
        const oldAlertsQuery = db.collection("alerts")
            .where("date", "<", cutoffDate)
            .limit(500); // Process in batches to avoid timeout

        const snapshot = await oldAlertsQuery.get();

        if (snapshot.empty) {
          console.log("‚úì No old alerts to delete");
          return null;
        }

        // Delete alerts in batch
        const batch = db.batch();
        snapshot.docs.forEach((doc) => {
          batch.delete(doc.ref);
        });

        await batch.commit();
        console.log(`‚úì Deleted ${snapshot.size} old alerts from before ${cutoffDate}`);

        // If we hit the limit, there might be more to delete
        // Schedule another cleanup run
        if (snapshot.size === 500) {
          console.log("‚ö†Ô∏è Batch limit reached (500 docs), more alerts may need cleanup");
          console.log("üí° Tip: Consider running cleanup more frequently or increasing batch size");
        }

        return {
          deleted: snapshot.size,
          cutoffDate: cutoffDate,
          cutoffTimestamp: cutoffTimestamp,
        };
      } catch (error) {
        console.error("‚ùå Error cleaning up old alerts:", error);
        return null;
      }
    });

/**
 * Cloud Function: Store sensor data to Firestore
 * Triggers whenever sensorData is updated in Realtime Database
 * Creates aggregated records in Firestore (NO raw sensor readings)
 */
exports.storeSensorDataToFirestore = onValueUpdated(
    {
      ref: "/sensorData",
      region: "asia-southeast1",
      instance: "tearrarium-iot-monitoring-default-rtdb",
    },
    async (event) => {
      const change = event.data;
      try {
        const newData = change.after.val();
        const oldData = change.before.val();

        // Only store if data has actually changed
        if (JSON.stringify(newData) === JSON.stringify(oldData)) {
          console.log("No change in data, skipping...");
          return null;
        }

        const timestamp = admin.firestore.FieldValue.serverTimestamp();
        const timestampMillis = Date.now();
        const date = new Date(timestampMillis).toISOString().split("T")[0];
        const hour = new Date(timestampMillis).getHours();

        // Prepare base data
        const sensorData = {
          temperature: newData.temperature || 0,
          humidity: newData.humidity || 0,
          moisture: newData.moisture || 0,
          lux: newData.lux || 0,
        };

        // 1. Update latest reading ONLY
        await db.collection("latestReadings").doc("current").set({
          ...sensorData,
          timestamp: timestamp,
          timestampMillis: timestampMillis,
          date: date,
          hour: hour,
          controls: {
            humidifierState: (newData.controls &&
                newData.controls.humidifierState) || false,
            lightBrightness: (newData.controls &&
                newData.controls.lightBrightness) || 0,
          },
        });
        console.log("‚úì Updated latest reading");

        // // 2. Update hourly aggregates
        const hourlyDocId = `${date}_${hour}`;
        const hourlyRef = db.collection("hourlyAggregates").doc(hourlyDocId);

        await db.runTransaction(async (transaction) => {
          const hourlyDoc = await transaction.get(hourlyRef);

          if (!hourlyDoc.exists) {
            transaction.set(hourlyRef, {
              date: date,
              hour: hour,
              count: 1,
              temperature: {
                sum: sensorData.temperature,
                min: sensorData.temperature,
                max: sensorData.temperature,
                avg: sensorData.temperature,
              },
              humidity: {
                sum: sensorData.humidity,
                min: sensorData.humidity,
                max: sensorData.humidity,
                avg: sensorData.humidity,
              },
              moisture: {
                sum: sensorData.moisture,
                min: sensorData.moisture,
                max: sensorData.moisture,
                avg: sensorData.moisture,
              },
              lux: {
                sum: sensorData.lux,
                min: sensorData.lux,
                max: sensorData.lux,
                avg: sensorData.lux,
              },
              lastUpdated: timestamp,
            });
          } else {
            const data = hourlyDoc.data();
            const newCount = data.count + 1;

            transaction.update(hourlyRef, {
              count: newCount,
              temperature: {
                sum: data.temperature.sum + sensorData.temperature,
                min: Math.min(data.temperature.min, sensorData.temperature),
                max: Math.max(data.temperature.max, sensorData.temperature),
                avg: (data.temperature.sum + sensorData.temperature) /
                    newCount,
              },
              humidity: {
                sum: data.humidity.sum + sensorData.humidity,
                min: Math.min(data.humidity.min, sensorData.humidity),
                max: Math.max(data.humidity.max, sensorData.humidity),
                avg: (data.humidity.sum + sensorData.humidity) / newCount,
              },
              moisture: {
                sum: data.moisture.sum + sensorData.moisture,
                min: Math.min(data.moisture.min, sensorData.moisture),
                max: Math.max(data.moisture.max, sensorData.moisture),
                avg: (data.moisture.sum + sensorData.moisture) / newCount,
              },
              lux: {
                sum: data.lux.sum + sensorData.lux,
                min: Math.min(data.lux.min, sensorData.lux),
                max: Math.max(data.lux.max, sensorData.lux),
                avg: (data.lux.sum + sensorData.lux) / newCount,
              },
              lastUpdated: timestamp,
            });
          }
        });
        console.log("‚úì Updated hourly aggregate");

        // 3. Update daily summary
        const dailyDocId = date;
        const dailyRef = db.collection("dailySummaries").doc(dailyDocId);

        await db.runTransaction(async (transaction) => {
          const dailyDoc = await transaction.get(dailyRef);

          if (!dailyDoc.exists) {
            transaction.set(dailyRef, {
              date: date,
              readingCount: 1,
              temperature: {
                min: sensorData.temperature,
                max: sensorData.temperature,
                avg: sensorData.temperature,
              },
              humidity: {
                min: sensorData.humidity,
                max: sensorData.humidity,
                avg: sensorData.humidity,
              },
              moisture: {
                min: sensorData.moisture,
                max: sensorData.moisture,
                avg: sensorData.moisture,
              },
              lux: {
                min: sensorData.lux,
                max: sensorData.lux,
                avg: sensorData.lux,
              },
              lastUpdated: timestamp,
            });
          } else {
            const data = dailyDoc.data();
            const newCount = data.readingCount + 1;

            transaction.update(dailyRef, {
              readingCount: newCount,
              temperature: {
                min: Math.min(data.temperature.min, sensorData.temperature),
                max: Math.max(data.temperature.max, sensorData.temperature),
                avg: ((data.temperature.avg * data.readingCount) +
                    sensorData.temperature) / newCount,
              },
              humidity: {
                min: Math.min(data.humidity.min, sensorData.humidity),
                max: Math.max(data.humidity.max, sensorData.humidity),
                avg: ((data.humidity.avg * data.readingCount) +
                    sensorData.humidity) / newCount,
              },
              moisture: {
                min: Math.min(data.moisture.min, sensorData.moisture),
                max: Math.max(data.moisture.max, sensorData.moisture),
                avg: ((data.moisture.avg * data.readingCount) +
                    sensorData.moisture) / newCount,
              },
              lux: {
                min: Math.min(data.lux.min, sensorData.lux),
                max: Math.max(data.lux.max, sensorData.lux),
                avg: ((data.lux.avg * data.readingCount) +
                    sensorData.lux) / newCount,
              },
              lastUpdated: timestamp,
            });
          }
        });
        console.log("‚úì Updated daily summary");

        return null;
      } catch (error) {
        console.error("Error storing sensor data:", error);
        return null;
      }
    });

/**
 * Cloud Function: Cleanup old hourly aggregates
 * Runs daily to delete hourly data older than 7 days
 * (Daily summaries are kept longer)
 */
exports.cleanupOldHourlyAggregates = onSchedule(
    {
      schedule: "every 24 hours",
      region: "asia-southeast1",
    },
    async (event) => {
      try {
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        const cutoffDate = sevenDaysAgo.toISOString().split("T")[0];

        const oldAggregatesQuery = db.collection("hourlyAggregates")
            .where("date", "<", cutoffDate)
            .limit(500);

        const snapshot = await oldAggregatesQuery.get();

        if (snapshot.empty) {
          console.log("No old hourly aggregates to delete");
          return null;
        }

        const batch = db.batch();
        snapshot.docs.forEach((doc) => {
          batch.delete(doc.ref);
        });

        await batch.commit();
        console.log(`‚úì Deleted ${snapshot.size} old hourly aggregates`);

        return null;
      } catch (error) {
        console.error("Error cleaning up old hourly aggregates:", error);
        return null;
      }
    });

/**
 * Cloud Function: Cleanup old daily summaries
 * Runs daily to delete daily summaries older than 90 days
 */
exports.cleanupOldDailySummaries = onSchedule(
    {
      schedule: "every 24 hours",
      region: "asia-southeast1",
    },
    async (event) => {
      try {
        const ninetyDaysAgo = new Date();
        ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
        const cutoffDate = ninetyDaysAgo.toISOString().split("T")[0];

        const oldSummariesQuery = db.collection("dailySummaries")
            .where("date", "<", cutoffDate)
            .limit(500);

        const snapshot = await oldSummariesQuery.get();

        if (snapshot.empty) {
          console.log("No old daily summaries to delete");
          return null;
        }

        const batch = db.batch();
        snapshot.docs.forEach((doc) => {
          batch.delete(doc.ref);
        });

        await batch.commit();
        console.log(`‚úì Deleted ${snapshot.size} old daily summaries`);

        return null;
      } catch (error) {
        console.error("Error cleaning up old daily summaries:", error);
        return null;
      }
    });

/**
 * Cloud Function: Store sensor alerts for email reports
 * Monitors sensor data and stores alerts based on threshold violations
 * Thresholds are dynamically synced from the user's selected ecosystem
 * Data is stored in Firestore for email report generation
 */

// Ecosystem-specific thresholds (matching ecosystemLimiter.tsx)
const ECOSYSTEM_THRESHOLDS = {
  tropical: {
    temperature: {
      min: 25,
      max: 30,
      critical_low: 20,
      critical_high: 35,
      warning_low: 22,
      warning_high: 33,
    },
    humidity: {
      min: 70,
      max: 90,
      critical_low: 50,
      critical_high: 95,
      warning_low: 60,
      warning_high: 92,
    },
    moisture: {
      min: 40,
      max: 60,
      critical_low: 25,
      critical_high: 70,
      warning_low: 30,
      warning_high: 65,
    },
    lux: {
      min: 1000,
      max: 10000,
      critical_low: 500,
      critical_high: 60000,
      warning_low: 800,
      warning_high: 40000,
    },
  },
  woodland: {
    temperature: {
      min: 16,
      max: 24,
      critical_low: 10,
      critical_high: 28,
      warning_low: 12,
      warning_high: 26,
    },
    humidity: {
      min: 60,
      max: 85,
      critical_low: 45,
      critical_high: 90,
      warning_low: 50,
      warning_high: 88,
    },
    moisture: {
      min: 35,
      max: 60,
      critical_low: 20,
      critical_high: 70,
      warning_low: 25,
      warning_high: 65,
    },
    lux: {
      min: 1000,
      max: 5000,
      critical_low: 500,
      critical_high: 8000,
      warning_low: 700,
      warning_high: 7000,
    },
  },
  bog: {
    temperature: {
      min: 18,
      max: 30,
      critical_low: 12,
      critical_high: 35,
      warning_low: 15,
      warning_high: 32,
    },
    humidity: {
      min: 70,
      max: 95,
      critical_low: 60,
      critical_high: 98,
      warning_low: 65,
      warning_high: 96,
    },
    moisture: {
      min: 70,
      max: 100,
      critical_low: 60,
      critical_high: 100,
      warning_low: 65,
      warning_high: 98,
    },
    lux: {
      min: 5000,
      max: 15000,
      critical_low: 3000,
      critical_high: 20000,
      warning_low: 4000,
      warning_high: 18000,
    },
  },
  paludarium: {
    temperature: {
      min: 22,
      max: 28,
      critical_low: 18,
      critical_high: 32,
      warning_low: 20,
      warning_high: 30,
    },
    humidity: {
      min: 70,
      max: 95,
      critical_low: 60,
      critical_high: 98,
      warning_low: 65,
      warning_high: 96,
    },
    moisture: {
      min: 50,
      max: 80,
      critical_low: 35,
      critical_high: 90,
      warning_low: 40,
      warning_high: 85,
    },
    lux: {
      min: 2000,
      max: 10000,
      critical_low: 1000,
      critical_high: 15000,
      warning_low: 1500,
      warning_high: 12000,
    },
  },
};

exports.generateSensorAlerts = onValueUpdated(
    {
      ref: "/sensorData",
      region: "asia-southeast1",
      instance: "tearrarium-iot-monitoring-default-rtdb",
    },
    async (event) => {
      const change = event.data;
      try {
        const newData = change.after.val();
        const timestamp = admin.firestore.FieldValue.serverTimestamp();
        const timestampMillis = Date.now();
        const dateStr = new Date(timestampMillis).toISOString().split("T")[0];

        // Get UID from sensor data (assuming it contains uid field)
        const uid = newData.uid;
        if (!uid) {
          console.warn(
              "‚ö†Ô∏è No UID found in sensor data, using default thresholds");
        }

        let ecosystem = "tropical"; // Default ecosystem

        // Fetch user profile to get selected ecosystem
        if (uid) {
          try {
            const profileDoc = await db.collection("profile").doc(uid).get();
            if (profileDoc.exists) {
              const profileData = profileDoc.data();
              ecosystem = profileData.terrariumEco || "tropical";
              console.log(
                  `‚úì Using ecosystem thresholds for user ${uid}: ${ecosystem}`);
            } else {
              console.warn(
                  `‚ö†Ô∏è Profile not found for UID: ${uid}, using default`);
            }
          } catch (err) {
            console.error(`‚ùå Error fetching user profile: ${err.message}`);
            console.log("‚ÑπÔ∏è Falling back to default tropical thresholds");
          }
        }

        // ===== RATE LIMITING CHECK =====
        // Check if we've already posted an alert in the last hour
        const oneHourAgo = timestampMillis - (60 * 60 * 1000);
        const recentAlertsQuery = await db.collection("alerts")
            .where("uid", "==", uid)
            .where("timestampMillis", ">=", oneHourAgo)
            .limit(1)
            .get();

        if (!recentAlertsQuery.empty) {
          console.log(
              `‚è±Ô∏è Rate limit: Alert already posted within hour for ${uid}`);
          return null;
        }

        // Check daily alert count (max 5 per day)
        const startOfDay = new Date(dateStr).getTime();
        const endOfDay = startOfDay + (24 * 60 * 60 * 1000);

        const dailyAlertsQuery = await db.collection("alerts")
            .where("uid", "==", uid)
            .where("timestampMillis", ">=", startOfDay)
            .where("timestampMillis", "<", endOfDay)
            .get();

        if (dailyAlertsQuery.size >= 50) { // 5
          console.log(
              `üìä Daily limit: ${dailyAlertsQuery.size} alerts today for ${uid}`,
          );
          return null;
        }

        console.log(
            `‚úÖ Rate limit passed: ${dailyAlertsQuery.size}/5 alerts today`);
        // ===== END RATE LIMITING CHECK =====

        // Get ecosystem-specific thresholds
        const thresholds = ECOSYSTEM_THRESHOLDS[ecosystem];
        console.log(`üéØ Applied thresholds for ecosystem: ${ecosystem}`);

        const alerts = [];

        // Check temperature
        if (newData.temperature < thresholds.temperature.critical_low) {
          alerts.push({
            type: "temperature",
            severity: "critical",
            message: `CRITICAL: Temperature too low (${newData.temperature}¬∞C)`,
            value: newData.temperature,
            threshold: thresholds.temperature.critical_low,
            date: dateStr,
          });
        } else if (newData.temperature > thresholds.temperature.critical_high) {
          alerts.push({
            type: "temperature",
            severity: "critical",
            message:
                `CRITICAL: Temperature too high (${newData.temperature}¬∞C)`,
            value: newData.temperature,
            threshold: thresholds.temperature.critical_high,
            date: dateStr,
          });
        } else if (newData.temperature < thresholds.temperature.warning_low) {
          alerts.push({
            type: "temperature",
            severity: "warning",
            message: `WARNING: Temperature low (${newData.temperature}¬∞C)`,
            value: newData.temperature,
            threshold: thresholds.temperature.warning_low,
            date: dateStr,
          });
        } else if (newData.temperature > thresholds.temperature.warning_high) {
          alerts.push({
            type: "temperature",
            severity: "warning",
            message: `WARNING: Temperature high (${newData.temperature}¬∞C)`,
            value: newData.temperature,
            threshold: thresholds.temperature.warning_high,
            date: dateStr,
          });
        }

        // Check humidity
        if (newData.humidity < thresholds.humidity.critical_low) {
          alerts.push({
            type: "humidity",
            severity: "critical",
            message: `CRITICAL: Humidity too low (${newData.humidity}%)`,
            value: newData.humidity,
            threshold: thresholds.humidity.critical_low,
            date: dateStr,
          });
        } else if (newData.humidity > thresholds.humidity.critical_high) {
          alerts.push({
            type: "humidity",
            severity: "critical",
            message: `CRITICAL: Humidity too high (${newData.humidity}%)`,
            value: newData.humidity,
            threshold: thresholds.humidity.critical_high,
            date: dateStr,
          });
        } else if (newData.humidity < thresholds.humidity.warning_low) {
          alerts.push({
            type: "humidity",
            severity: "warning",
            message: `WARNING: Humidity low (${newData.humidity}%)`,
            value: newData.humidity,
            threshold: thresholds.humidity.warning_low,
            date: dateStr,
          });
        } else if (newData.humidity > thresholds.humidity.warning_high) {
          alerts.push({
            type: "humidity",
            severity: "warning",
            message: `WARNING: Humidity high (${newData.humidity}%)`,
            value: newData.humidity,
            threshold: thresholds.humidity.warning_high,
            date: dateStr,
          });
        }

        // Check moisture
        if (newData.moisture < thresholds.moisture.critical_low) {
          alerts.push({
            type: "moisture",
            severity: "critical",
            message: `CRITICAL: Soil too dry (${newData.moisture}%)`,
            value: newData.moisture,
            threshold: thresholds.moisture.critical_low,
            date: dateStr,
          });
        } else if (newData.moisture > thresholds.moisture.critical_high) {
          alerts.push({
            type: "moisture",
            severity: "critical",
            message: `CRITICAL: Soil too wet (${newData.moisture}%)`,
            value: newData.moisture,
            threshold: thresholds.moisture.critical_high,
            date: dateStr,
          });
        } else if (newData.moisture < thresholds.moisture.warning_low) {
          alerts.push({
            type: "moisture",
            severity: "warning",
            message: `WARNING: Soil dry (${newData.moisture}%)`,
            value: newData.moisture,
            threshold: thresholds.moisture.warning_low,
            date: dateStr,
          });
        } else if (newData.moisture > thresholds.moisture.warning_high) {
          alerts.push({
            type: "moisture",
            severity: "warning",
            message: `WARNING: Soil wet (${newData.moisture}%)`,
            value: newData.moisture,
            threshold: thresholds.moisture.warning_high,
            date: dateStr,
          });
        }

        // Check light
        if (newData.lux < thresholds.lux.critical_low) {
          alerts.push({
            type: "lux",
            severity: "critical",
            message: `CRITICAL: Light too low (${newData.lux} lux)`,
            value: newData.lux,
            threshold: thresholds.lux.critical_low,
            date: dateStr,
          });
        } else if (newData.lux > thresholds.lux.critical_high) {
          alerts.push({
            type: "lux",
            severity: "critical",
            message: `CRITICAL: Light too high (${newData.lux} lux)`,
            value: newData.lux,
            threshold: thresholds.lux.critical_high,
            date: dateStr,
          });
        } else if (newData.lux < thresholds.lux.warning_low) {
          alerts.push({
            type: "lux",
            severity: "warning",
            message: `WARNING: Light low (${newData.lux} lux)`,
            value: newData.lux,
            threshold: thresholds.lux.warning_low,
            date: dateStr,
          });
        } else if (newData.lux > thresholds.lux.warning_high) {
          alerts.push({
            type: "lux",
            severity: "warning",
            message: `WARNING: Light high (${newData.lux} lux)`,
            value: newData.lux,
            threshold: thresholds.lux.warning_high,
            date: dateStr,
          });
        }

        // Store all alerts to Firestore for email reports
        if (alerts.length > 0) {
          const batch = db.batch();
          alerts.forEach((alert) => {
            const alertRef = db.collection("alerts").doc();
            batch.set(alertRef, {
              ...alert,
              ecosystem: ecosystem,
              uid: uid,
              timestamp: timestamp,
              timestampMillis: timestampMillis,
              createdAt: timestamp,
            });
          });
          await batch.commit();
          console.log(
              `‚úì Stored ${alerts.length} alert(s) to Firestore for ` +
              `${ecosystem} ecosystem`);

          // Send email notifications for critical alerts
          const criticalAlerts = alerts.filter(
              (alert) => alert.severity === "critical");

          if (criticalAlerts.length > 0 && uid) {
            try {
              // Fetch user profile to get their email address
              const profileDoc = await db.collection("profile").doc(uid).get();

              if (profileDoc.exists) {
                const userData = profileDoc.data();
                const userEmail = userData.email;

                if (userEmail) {
                  // Send email for each critical alert
                  await Promise.all(
                      criticalAlerts.map((alert) =>
                        sendAlertEmail(userEmail, alert, ecosystem),
                      ),
                  );
                  console.log(
                      `‚úâÔ∏è Sent ${criticalAlerts.length} critical alert ` +
                      `email(s) to ${userEmail}`,
                  );
                } else {
                  console.warn(`‚ö†Ô∏è No email found in profile for user ${uid}`);
                }
              } else {
                console.warn(`‚ö†Ô∏è Profile document not found for user ${uid}`);
              }
            } catch (emailError) {
              console.error("‚ùå Failed to send email notifications:",
                  emailError);
            }
          }
        } else {
          console.log(`‚ÑπÔ∏è No alerts triggered for current sensor readings`);
        }

        return null;
      } catch (error) {
        console.error("Error generating sensor alerts:", error);
        return null;
      }
    });
